// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package MyRobot.subsystems;

import com.ctre.CANTalon;

import MyRobot.RobotMap;
import MyRobot.commands.*;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Drive extends Subsystem {
	
	private static final double MAX_MOTOR_RPM = 4000;
	private static final double WHEEL_DIAMETER = 4.0;
	private static final double GEAR_RATIO = 8.45;
	private static final double MAX_WHEEL_RPM = MAX_MOTOR_RPM / GEAR_RATIO;

    public static final double WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * Math.PI;
    public static final double MAX_SPEED_IPM = WHEEL_CIRCUMFERENCE * MAX_WHEEL_RPM;
    public static final double MAX_SPEED_IPS = MAX_SPEED_IPM / 60.0;
    public static final double WHEEL_BASE = 27.75; // distance between wheel centers

    private static final double ROTATION_CIRCLE = Math.PI * WHEEL_BASE;
    private static final double MAX_TURN_RATE = MAX_SPEED_IPS / ROTATION_CIRCLE;

    public static final double MAX_TURN_RATE_DPS = MAX_TURN_RATE * 360.0;
    
    private final CANTalon cANTalon1 = RobotMap.driveCANTalon1;
    private final CANTalon cANTalon2 = RobotMap.driveCANTalon2;
    private final RobotDrive robotDrive = RobotMap.driveRobotDrive21;

    public void initDefaultCommand() {

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void driveValues(double forward, double turnRate) {
    	robotDrive.arcadeDrive(forward, turnRate);
    }
    
    public void setSafety(boolean safely) {
    	robotDrive.setSafetyEnabled(safely);
    }
    
    public double speedFromPower(double power) {
    	double result = Math.max(0, 71.882*power*power + 39.665* power - 11.083);
    	return result;
    }
    
    // convert inches per second into +/- 1
    public double powerFromSpeed(double speed) {
    	double magnitude = Math.abs(speed);
    	double power = -0.00003*magnitude*magnitude + 0.0111*magnitude + 0.2176;
    	double fixed = Math.min(1.0, power);
    	return fixed * Math.signum(speed);
    }
    
    // convert degrees per second into +/- 1
    public double powerFromTurnRate(double turnRate) {
    	double fixed = powerFromSpeed(turnRate);
    	return fixed * Math.signum(turnRate);
    }
    
    public void driveSpeed(double forwardSpeed, double turnRate) {
    	double power = powerFromSpeed(forwardSpeed);
    	double turns = turnRate / MAX_TURN_RATE_DPS;
    	robotDrive.drive(power, turns);
    }
    
    public void driveTurn(double turnRate) {
    	double curve = (turnRate / MAX_TURN_RATE_DPS) * 3;
    	robotDrive.drive(curve, 1.0);
    }
}

